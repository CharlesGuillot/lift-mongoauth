package com.eltimn
package auth.mongo

import shiro.sitemap.Locs._

import org.bson.types.ObjectId
import org.joda.time.DateTime

import net.liftweb._
import common._
import http._

object AuthLocs extends shiro.SubjectLifeCycle {

  private lazy val authTokenMeta = AuthRules.authTokenMeta.vend

  private def handleAuthToken: LiftResponse = {
    var retVar = RedirectResponse(redirectPath)
    S.param("token") match {
      case Full(t) if (ObjectId.isValid(t)) => authTokenMeta.find(new ObjectId(t)) match {
        case Full(at) if ((new DateTime).getMillis >= (new DateTime(at.expires.value)).getMillis) => {
          S.error("Auth token has expired.")
          at.delete_!
        }
        case Full(at) => {
          at.userId.obj match {
            case Full(u) => {
              // update validated
              u.verified(true)
              u.save
              at.delete_!
              login(new AuthTokenToken(u.id.is))
              retVar = RedirectResponse(AuthRules.authAfterAuthToken.vend) // need new transition page to allow user to select to set a password and/or to "remember me"
            }
            case _ => S.error("User not found.")
          }
        }
        case _ => S.error("Invalid auth token.")
      }
      case _ => S.warning("Auth token not provided.")
    }

    retVar
  }

  def authTokenMenu = Menu.i("Auth") / "auth" >> RequireRemembered >> EarlyResponse(() => {
    handleAuthToken
  })
}


